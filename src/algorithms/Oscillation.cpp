// Oscillation.cpp automatically generated by bin/add_new_algorithm.pl
// in Wed Mar  4 12:50:18 2020.

//
// Oscillation.cpp -- implementation of the class "Oscillation".
//
//    This file is part of the featsel program
//    Copyright (C) 2016  Marcelo S. Reis
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#include "Oscillation.h"


Oscillation::Oscillation ()
{
  list_of_visited_subsets = new Collection ();
  cost_function = NULL;
}


Oscillation::~Oscillation ()
{
  if (list_of_visited_subsets != NULL)
  delete list_of_visited_subsets;
}


void Oscillation::get_minima_list (unsigned int max_size_of_minima_list)
{
 timeval begin_program, end_program;
  gettimeofday (& begin_program, NULL);

  ElementSubset W ("W", set), X ("X", set), Y ("Y", set), *Z;
  unsigned int i, j, k;
  double n = (double) set->get_set_cardinality ();
  unsigned int number_of_violations = 0;

  X.set_empty_subset (); // X starts with empty set

  do  // Amortized time per iteration is O(1) + O(f(n))
  {
    i = 0;

    while ((i < n) && (X.has_element (i)))
    {
      X.remove_element (i);
      i++;
    }

    if (i < n)
      X.add_element (i);

    if (store_visited_subsets)
     list_of_visited_subsets->add_subset (&X);

    X.cost = cost_function->cost (&X);  // O(f(n))

    W.copy(&X); // Lower adjacent.
    Y.copy(&X); // Upper adjacent.
    
    if ((X.get_subset_cardinality() > 1) &&
        (X.get_subset_cardinality() < n))
    {
      // Lower adjacents.
      //
      for (k = 0; k < n; k++)
      {
        for (j = 0; j < n; j++)
        {
          if ((X.has_element(k)) && (! X.has_element(j)))
          {
            W.remove_element(k);
            Y.add_element(j);
            
            W.cost = cost_function->cost(&W);
            Y.cost = cost_function->cost(&Y);
            
            // c(X) > max{c(W), c(Y)} ?
            //
            if ((X.cost > W.cost) && (X.cost > Y.cost))
              number_of_violations++;

            W.add_element(k);
            Y.remove_element(j);
          }
        }
      }
    }
    
}
  while ( (i < n) && (!cost_function->has_reached_threshold ()) );

  // Exhaustive search, if implemented keeping just an element of minimum cost,
  // needs to compute the cost function 2^|S| times.
  //
  number_of_visited_subsets =
  cost_function->get_number_of_calls_of_cost_function ();

  gettimeofday (& end_program, NULL);
  elapsed_time_of_the_algorithm = diff_us (end_program, begin_program);

  // The number of violations is returned in an empty set for featsel main
  // program (thus it can be retrieved by the run_benchmarking program).
  //
  Z = new ElementSubset ("number of violations", set);
  Z->cost = number_of_violations;
  list_of_minima.push_back(Z);
    
}


