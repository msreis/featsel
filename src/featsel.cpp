// featsel.cpp automatically generated by bin/build_featsel_main_file.pl
// in Mon Dec  2 10:54:37 2019.

//============================================================================
//
//    featsel -- a flexible feature selection program.
//    Copyright (C) 2017  Marcelo S. Reis
//
//
//   If you use featsel in your publication, we kindly ask you to acknowledge us
//   by citing the paper that describes this framework:
//
//   M.S. Reis, G. Estrela, C.E. Ferreira and J. Barrera
//   "featsel: A Framework for Benchmarking of
//   Feature Selection Algorithms and Cost Functions"
//   SoftwareX 6 (2017) pp. 193-197.
//   DOI: 10.1016/j.softx.2017.07.005.
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
//============================================================================


# include "global.h"
# include "string.h"
# include "ElementSet.h"
# include "CostFunction.h"

# define noop   // no operation

#include "functions/Explicit.h"
#include "functions/MeanConditionalEntropy.h"
#include "functions/HammingDistance.h"
#include "functions/SubsetSum.h"
#include "functions/MutualInformation.h"
#include "functions/ConditionalMutualInformation.h"
#include "functions/Point.h"
#include "functions/TailorConvexHull.h"
#include "functions/CFS.h"
#include "functions/ABD.h"
#include "functions/SigNetSim.h"

#include "algorithms/UcurveBranchandBound.h"
#include "algorithms/ExhaustiveSearch.h"
#include "algorithms/SFS.h"
#include "algorithms/SFFS.h"
#include "algorithms/UCurveSearch.h"
#include "algorithms/RandomChain.h"
#include "algorithms/SBFS.h"
#include "algorithms/SBS.h"
#include "algorithms/BFS.h"
#include "algorithms/UCSR.h"
#include "algorithms/RandomUChain.h"
#include "algorithms/KRandomUChain.h"
#include "algorithms/CHCGA.h"
#include "algorithms/RBM.h"
#include "algorithms/PUCS.h"
#include "algorithms/PosetForestSearch.h"


// Function to parse and verify the correctness of the parameters.
// It returns '0' if all the parameters were correct, '1' if there was an error,
// and '2' if the option '-h' (help) was called.
//
int parse_parameters
  (int, char **, string *, unsigned int *, string *,
   unsigned int *, unsigned int *, bool *, string *, unsigned int *, double * p,
   unsigned int *, unsigned int *, unsigned int *);


// The main function.
//
int main(int argc, char * argv[])
{
  unsigned int max_number_of_minima = 1;
  unsigned int n = 3;
  unsigned int range = 1000;
  unsigned int number_of_labels = 2;
  unsigned int l = 2;                                         // PUCS parameter.
  unsigned int max_number_of_calls_of_cost_function = 0;      // 0 for no limit.
  double p = .5;                                              // PUCS parameter.
  unsigned int k = 10;        // Spec-CMI parameter.
  int i;
  CostFunction * cost_function;
  Solver * solver;
  ElementSet * S;
  string list;
  string a_cost_function ("subset_sum");
  string algorithm ("ubb");
  string file_name;
  bool store_visited_subsets = false;
  ofstream log_file;

  srand ((unsigned) time (NULL));

  // Parse the parameters
  //
  i = parse_parameters(argc, argv, &file_name, &max_number_of_minima,
      &a_cost_function, &n, &range, &store_visited_subsets, &algorithm,
      &max_number_of_calls_of_cost_function, &p, &l, &number_of_labels, &k);

  if (i != EXIT_SUCCESS)    // Help or error in parameters
    return EXIT_FAILURE;

  // Select the type of instance (from XML file, from DAT file, or random)
  //
  if ((file_name.size () > 0) && ((file_name.find (".xml") != string::npos) ||
      (file_name.find (".XML") != string::npos)))
    S = new ElementSet ("S", file_name.data ());
  else if ((file_name.size () > 0) &&
           ((file_name.find (".dat") != string::npos) ||
            (file_name.find (".DAT") != string::npos)))
    S = new ElementSet (number_of_labels, file_name.data (), n);
  else
    S = new ElementSet ("S", n, range);

  // Instantiate an object of the selected solver (algorithm)
  //
  if (0)
    noop;
  else if (algorithm.compare ("ubb") == 0)
    solver = new UcurveBranchandBound ();
  else if (algorithm.compare ("es") == 0)
    solver = new ExhaustiveSearch ();
  else if (algorithm.compare ("sfs") == 0)
    solver = new SFS ();
  else if (algorithm.compare ("sffs") == 0)
    solver = new SFFS ();
  else if (algorithm.compare ("ucs") == 0)
    solver = new UCurveSearch ();
  else if (algorithm.compare ("rc") == 0)
    solver = new RandomChain ();
  else if (algorithm.compare ("sbfs") == 0)
    solver = new SBFS ();
  else if (algorithm.compare ("sbs") == 0)
    solver = new SBS ();
  else if (algorithm.compare ("bfs") == 0)
    solver = new BFS ();
  else if (algorithm.compare ("ucsr") == 0)
    solver = new UCSR ();
  else if (algorithm.compare ("ruc") == 0)
    solver = new RandomUChain ();
  else if (algorithm.compare ("kruc") == 0)
    solver = new KRandomUChain ();
  else if (algorithm.compare ("chcga") == 0)
    solver = new CHCGA ();
  else if (algorithm.compare ("rbm") == 0)
    solver = new RBM ();
  else if (algorithm.compare ("pucs") == 0)
    solver = new PUCS (p, l);
  else if (algorithm.compare ("pfs") == 0)
    solver = new PosetForestSearch ();
  else
    return EXIT_FAILURE;

  // Instantiate an object of the selected cost function
  //
  if (0)
    noop;
  else if (a_cost_function.compare ("explicit") == 0)
    cost_function = new Explicit (S);
  else if (a_cost_function.compare ("mce") == 0)
    cost_function = new MeanConditionalEntropy (S);
  else if (a_cost_function.compare ("hamming_distance") == 0)
    cost_function = new HammingDistance (S);
  else if (a_cost_function.compare ("subset_sum") == 0)
    cost_function = new SubsetSum (S);
  else if (a_cost_function.compare ("mi") == 0)
    cost_function = new MutualInformation (S);
  else if (a_cost_function.compare ("cmi") == 0)
    cost_function = new ConditionalMutualInformation (S);
  else if (a_cost_function.compare ("point") == 0)
    cost_function = new Point (S);
  else if (a_cost_function.compare ("tailor") == 0)
    cost_function = new TailorConvexHull (S);
  else if (a_cost_function.compare ("cfs") == 0)
    cost_function = new CFS (S);
  else if (a_cost_function.compare ("abd") == 0)
    cost_function = new ABD (S);
  else if (a_cost_function.compare ("sns") == 0)
    cost_function = new SigNetSim (S);
  else
    return EXIT_FAILURE;

  // If the solver has a heuristic strategy, here we
  // set the maximum number of calls of the cost function
  //
  if (max_number_of_calls_of_cost_function > 0)
    cost_function->set_max_number_of_calls_of_cost_function
    (max_number_of_calls_of_cost_function);

  // Set the solver parameters
  //
  solver->set_parameters (cost_function, S, store_visited_subsets);

  // Run the solver
  //
  solver->get_minima_list (max_number_of_minima);

  // Print the results
  //
  cout << endl << "== List of best subsets found ==" << endl;
  cout << " X : c(X)" << endl;
  cout << solver->print_search_report ();
  if (store_visited_subsets)
  {
    cout << endl << "Visited subsets stored into 'visited.log' file" << endl;
    log_file.open ("output/visited.log");
    log_file << solver->print_list_of_visited_subsets () << endl;
    log_file.close ();
  }
  else
  {
    int elapsed_time =
    cost_function->get_the_elapsed_time_of_the_calls_of_this_cost_function ();

    // Number of visited subsets is the number of calls
    // of the cost function!
    //
    int number_of_subsets = solver->print_number_of_visited_subsets ();
    if (number_of_subsets > 0)
    {
      cout << "\nNumber of visited subsets: " <<  number_of_subsets << endl;
      cout << "Required time to compute the visited subsets: "
           << elapsed_time << " microseconds " << endl;
      cout << "(average " << elapsed_time / number_of_subsets
           << " microseconds per node)" << endl;
    }
    cout << endl << "Elapsed time of execution of the algorithm "
         << "(in microseconds): "
         << solver->get_elapsed_time_of_the_algorithm () << endl;
  }

  cout << endl << "== End of processing ==" << endl << endl;

  // Free allocated memory
  //
  delete S;
  delete solver;
  delete cost_function;

  // Exit to the OS
  //
  return EXIT_SUCCESS;

} // end of main



// parse_parameters function implementation
//
int parse_parameters (int argc, char ** argv, string * file_name,
	              unsigned int * m, string * c, unsigned int * n,
	              unsigned int * range, bool * keep_subsets, string * a,
	              unsigned int * max_number_of_calls_of_cost_function,
                  double * p, unsigned int * l, unsigned int * number_of_labels,
                      unsigned int * number_of_features)
{
  int i;
  bool error = false;
  string a_line;
  ifstream a_file;
  string disclaimer ("featsel -- a flexible feature selection program.\n\
Copyright (C) 2017  Marcelo S. Reis.\n\n \
This program comes with ABSOLUTELY NO WARRANTY.\n \
This is free software, and you are welcome to redistribute it\n \
under certain conditions; see 'LICENSE.TXT' for details. \n\n \
If you use featsel in your publication, we kindly ask you to acknowledge us \n \
by citing the paper that describes this framework: \n\n \
M.S. Reis, G. Estrela, C.E. Ferreira and J. Barrera \n \
'featsel: A Framework for Benchmarking of \n \
Feature Selection Algorithms and Cost Functions' \n \
SoftwareX 6 (2017) pp. 193-197.\n \
DOI: 10.1016/j.softx.2017.07.005.\n\n \
");

  // Parse the arguments
  //
  for (i = 1; i < argc; i++)
  {

    // -f
    //
    if ( (strcmp (argv[i],"-f") == 0) && ((i+1) < argc) )
    {
      a_file.open (argv[++i]);
      if (a_file.is_open ())
      {
        a_file.close ();
        file_name->append (argv[i]);
      }
      else
      {
        cout << "\nError: unable to open input file '" << argv[i] << "'!\n";
        error = true;
      }
    }
    else if ( (strcmp (argv[i],"-f") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-f' must have a file name." << endl;
      error = true;
    }

    // -r
    //
    else if ( (strcmp( argv[i],"-r") == 0) && ((i+1) < argc) )
    {
      *range = atoi (argv[++i]);
      if (*range >= RAND_MAX)
      {
        cout << "\nError: range should be in [0, " << RAND_MAX << ") !\n";
        error = true;
      }
    }
    else if ( (strcmp (argv[i],"-r") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-r' must have a value." << endl;
      error = true;
    }

    // -t   a limit to the number of calls of the cost function
    //
    else if ( (strcmp( argv[i],"-t") == 0) && ((i+1) < argc) )
    {
      *max_number_of_calls_of_cost_function = atoi (argv[++i]);
    }
    else if ( (strcmp (argv[i],"-t") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-t' must have a value." << endl;
      error = true;
    }

    // -n
    //
    else if ( (strcmp (argv[i],"-n") == 0) && ((i+1) < argc) )
    {
      if (atoi (argv[++i]) > 0)
        *n = atoi (argv[i]);
      else
      {
        cout << "\nError: number of elements should be a positive integer!\n";
        error = true;
      }
    }
    else if ( (strcmp (argv[i],"-n") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-n' must have a value." << endl;
      error = true;
    }

    // -c
    //
    else if ( (strcmp (argv[i],"-c") == 0) && ((i+1) < argc) )
    {
      i++;
      if ( (0) 
          || (strcmp (argv[i], "explicit") == 0)
          || (strcmp (argv[i], "mce") == 0)
          || (strcmp (argv[i], "hamming_distance") == 0)
          || (strcmp (argv[i], "subset_sum") == 0)
          || (strcmp (argv[i], "mi") == 0)
          || (strcmp (argv[i], "cmi") == 0)
          || (strcmp (argv[i], "point") == 0)
          || (strcmp (argv[i], "tailor") == 0)
          || (strcmp (argv[i], "cfs") == 0)
          || (strcmp (argv[i], "abd") == 0)
          || (strcmp (argv[i], "sns") == 0)
         )
      {
        c->clear();
        c->append(argv[i]);
      }
      else
      {
        cout << "\nError: unknown cost function '" << argv[i] << "'!" << endl;
        error = true;
      }
    }
    else if ( (strcmp (argv[i], "-a") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-c' must have a cost function name." << endl;
      error = true;
    }

    // -a
    //
    else if ( (strcmp(argv[i],"-a") == 0) && ((i+1) < argc) )
    {
      i++;
      if ( (0)  
          || (strcmp (argv[i], "ubb") == 0)
          || (strcmp (argv[i], "es") == 0)
          || (strcmp (argv[i], "sfs") == 0)
          || (strcmp (argv[i], "sffs") == 0)
          || (strcmp (argv[i], "ucs") == 0)
          || (strcmp (argv[i], "rc") == 0)
          || (strcmp (argv[i], "sbfs") == 0)
          || (strcmp (argv[i], "sbs") == 0)
          || (strcmp (argv[i], "bfs") == 0)
          || (strcmp (argv[i], "ucsr") == 0)
          || (strcmp (argv[i], "ruc") == 0)
          || (strcmp (argv[i], "kruc") == 0)
          || (strcmp (argv[i], "chcga") == 0)
          || (strcmp (argv[i], "rbm") == 0)
          || (strcmp (argv[i], "pucs") == 0)
          || (strcmp (argv[i], "pfs") == 0)
         )
      {
        a->clear ();
        a->append (argv[i]);
        if (strcmp (argv[i], "pucs") == 0) 
        {
          if (argv[i + 1][0] != '-')
            *p = atof (argv[++i]);
          if (argv[i + 1][0] != '-')
            *l = atoi (argv[++i]);
        }
      }
      else
      {
        cout << "\nError: unknown algorithm '" << argv[i] << "'!" << endl;
        error = true;
      }
    }
    else if ( (strcmp (argv[i], "-a") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-a' must have an algorithm name." << endl;
      error = true;
    }

    // -m
    //
    else if ( (strcmp (argv[i], "-m") == 0) && ((i+1) < argc) )
    {
      if (atoi (argv[++i]) > 0)
        *m = atoi (argv[i]);
      else
      {
        cout << "\nError: maximum number of minima should be "
             << "a positive integer!\n";
        error = true;
      }
    }
    else if ( (strcmp (argv[i],"-m") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-m' must have a value." << endl;
      error = true;
    }

    // -l
    //
    else if ( (strcmp (argv[i], "-l") == 0) && ((i+1) < argc) )
    {
      if (atoi (argv[++i]) > 0)
        *number_of_labels = atoi (argv[i]);
      else
      {
        cout << "\nError: number of labels should be "
             << "a positive integer!\n";
        error = true;
      }
    }
    else if ( (strcmp (argv[i],"-l") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-l' must have a value." << endl;
      error = true;
    }

    // -k
    //
    else if ( (strcmp (argv[i], "-k") == 0) && ((i+1) < argc) )
    {
      if (atoi (argv[++i]) > 0)
        *number_of_features = atoi (argv[i]);
      else
      {
        cout << "\nError: number of features to be selected should be "
             << "a positive integer!\n";
        error = true;
      }
    }
    else if ( (strcmp (argv[i],"-k") == 0) && ((i+1) >= argc) )
    {
      cout << "\nError: parameter '-k' must have a value." << endl;
      error = true;
    }

    // -s
    //
    else if (strcmp (argv[i],"-s") == 0)
    {
      *keep_subsets = true;
    }

    // -h
    //
    else if (strcmp (argv[i],"-h") == 0)
    {
      cout << endl << disclaimer << endl << endl;
      a_file.open ("docs/featsel.txt");
      if (a_file.is_open ())
        while(a_file.good ())
        {
          getline (a_file, a_line);
          cout << a_line << endl;
        }
      a_file.close ();
      return EXIT_FAILURE;
    }

    // Unknown option
    //
    else
    {
      cout <<  endl << "Unknown option '" << argv[i] << "'." << endl;
      error = true;
    }
  }

  // Show help dialog in case of error
  //
  if ( (error) || (argc == 1) )
  {
    cout << endl << disclaimer << endl;
    cout << endl << "Type 'featsel -h' for help." << endl << endl;
    return EXIT_FAILURE;
  }

  // Arguments parsed successfully
  //
  else
    return EXIT_SUCCESS;

} // End of function

